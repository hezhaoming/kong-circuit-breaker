---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hezhaoming.
--- DateTime: 2020/12/31 10:24 上午
--- 主要处理kong 组件的创建
local singletons = require "kong.singletons"
local plugins = kong.db.plugins
local admin_host = nil
local cjson = require "cjson"

-- http 请求方法
local HTTP_METHODS = {
    METHOD_GET = "GET",
    METHOD_POST = "POST",
    METHOD_DELETE = "DELETE",
}

-- auto register  server type
local SERVER_SUFFIX_LIST = {
    [1] = "SIMPLE",
    [2] = ".eureka.internal",
    [3] = ".zookpeer.internal",
    [4] = ".nacos.internal",
}

local KongAdminOperation = {}
KongAdminOperation.__index = KongAdminOperation

--- get kong admin api listeners default is 127.0.0.1:8001
local function get_admin_listen()
    for _, item in pairs(singletons.configuration.admin_listeners) do
        if not item['ssl'] then
            if "0.0.0.0" == item["ip"] then
                item["ip"] = "127.0.0.1"
            end
            return "http://" .. item["ip"] .. ":" .. item['port']
        end
    end
    return nil
end

--- http client of kong admin api
---@param method string http method like GET,POST,PUT,DELETE ...
---@param path string uri of path like /test
---@param body table request body
local function admin_client(method, path, body)
    if not admin_host then
        admin_host = get_admin_listen()
    end
    local httpClient = http.new()
    local req = {
        method = method,
        headers = { ["Content-Type"] = "application/json" },
        keepalive_timeout = 60,
        keepalive_pool = 10
    }
    LOG_DEBUG("send admin request,uri:", path, ",method:", method, "body:", body)
    if HTTP_METHODS.METHOD_POST == method and body then
        req["body"] = cjson.encode(body)
    end
    return httpClient:request_uri(admin_host .. path, req)
end

--- parse response
---@param type string type of operation
---@param resp table response of request
---@param err string error message
---@param cache_key string cache key
local function parse_resp(type, resp, err, cache_key)
    -- created success status is 201
    -- query success status is 200
    -- 409 is conflict
    -- query routes and targets ,status is 200 ,may be data is empty list
    if resp and (resp.status <= 201 or resp.status == 409) then
        if resp.status == 200 then
            local data = cjson.decode(resp.body)["data"]
            if data and #data == 0 then
                return "ok", nil
            end
        end
        kong_cache:safe_set(cache_key, true, cache_expire)
        return "ok", nil
    end
    if not resp or resp.status >= 400 then
        LOG_ERROR(resp.body)
        LOG_ERROR(
                "[" .. type .. "]failed to create kong request: http err msg:", err,
                ", http code:", resp.status, ", cache_key:", cache_key,
                ",response body:", resp.body)
        return nil, "failed to create kong " .. type
    end
    return "ok", nil
end

--- create service by app name、 serviceKey
---@param name string app name
function KongAdminOperation.create_service(name, server_suffix)
    -- 1. 判断缓存中，是否存在service
    local cache_key = "sync_eureka_apps:service:" .. name
    if kong_cache:get(cache_key) then
        return "ok", nil
    end
    -- 2. 判断数据库中是否存在service
    LOG_DEBUG("\n" .. "<<<[create service]:miss cache,we need to query this service:>>>", name)
    local res, err = admin_client(HTTP_METHODS.METHOD_GET, "/services/" .. name, nil)
    LOG_ERROR("res", res, err)
    parse_resp("service", res, err, cache_key)
    if kong_cache:get(cache_key) then
        return "ok", nil
    end
    -- 3. 新增一个service
    LOG_DEBUG("\n" .. "<<<[create service]:new service,we need to create this service:>>>", name)
    res, err = admin_client(HTTP_METHODS.METHOD_POST, "/services", { name = name, host = name .. SERVER_SUFFIX_LIST[server_suffix] })
    parse_resp("service", res, err, cache_key)
end

--- create route by app name
---@param name string app name
function KongAdminOperation.create_route(name)
    -- 1. 判断缓存中是否存在
    local cache_key = "sync_eureka_apps:route:" .. name
    if kong_cache:get(cache_key) then
        return "ok", nil
    end

    -- 2.判断数据库中，是否存在
    LOG_DEBUG("[create route]:miss cache,we need to query this route:", name)
    local res, err = admin_client(HTTP_METHODS.METHOD_GET, "/routes/" .. name, nil)
    parse_resp("route", res, err, cache_key)
    if kong_cache:get(cache_key) then
        return "ok", nil
    end

    -- 3.不存在则新增一个route
    LOG_DEBUG("[create route]:new route,we need to create this route:", name)
    res, err = admin_client(HTTP_METHODS.METHOD_POST, "/services/" .. name .. "/routes", {
        name = name,
        protocols = { "http" },
        paths = { "/" .. name }
    })
    parse_resp("route", res, err, cache_key)
end

--- create upstream by appname
---@param name string app name
---@param item table object of eureka's instance
function KongAdminOperation.create_upstream(name, server_suffix, item)
    -- 判断缓存中 upstream 是否存在
    local cache_key = "sync_eureka_apps:upstream:" .. name
    if kong_cache:get(cache_key) then
        return "ok", nil
    end

    -- 不存在则去数据库查询是否存在
    LOG_DEBUG("[create upstream]:miss cache,we need to query this upstream:", name)
    local res, err = admin_client(HTTP_METHODS.METHOD_GET, "/upstreams/" .. name .. SERVER_SUFFIX_LIST[server_suffix], nil)
    parse_resp("upstream", res, err, cache_key)
    if kong_cache:get(cache_key) then
        return "ok", nil
    end
    -- 都存在那么新增一个ups
    LOG_DEBUG("[create upstream]:new route,we need to create this upstream:", name)
    res, err = admin_client(HTTP_METHODS.METHOD_POST, "/upstreams", {
        name = name .. SERVER_SUFFIX_LIST[server_suffix],
        healthchecks = {
            -- passive check
            passive = {
                unhealthy = {
                    http_failures = 10,
                    timeouts = 40,
                    http_statuses = { 503, 504 }
                },
                healthy = { successes = 3 }
            }

        }
    })
    parse_resp("upstream", res, err, cache_key)
end

--- get targets by upstream name
---@param name string upstream name
---@param target_next string url of next targets page
function KongAdminOperation.get_targets(name, target_next)
    local res, err = admin_client(HTTP_METHODS.METHOD_GET, target_next, nil)
    local targets = {}
    if res and res.status == 200 then
        local target_resp = cjson.decode(res.body)
        LOG_DEBUG("[get targets]:path:", target_next, " ,length:", #target_resp["data"])
        for _, item in pairs(target_resp["data"]) do
            local kong_cache_key = "sync_eureka_apps:target:" .. name .. ":" .. item["target"]
            targets[item["target"]] = item["weight"]
            kong_cache:safe_set(kong_cache_key, true, cache_expire * 30)
        end
        if ngx.null ~= target_resp["next"] then
            LOG_DEBUG("[get targets]: next page, path:", target_resp["next"], " ,this page size:", #target_resp["data"])
            local next_targets = KongAdminOperation.get_targets(name, target_resp["next"])
            for key, value in pairs(next_targets) do
                targets[key] = value
            end
        end
    else
        return nil, err
    end
    return targets, nil
end

---delete unhealthy instance target
---@param name string app name
---@param target string app host:port
function KongAdminOperation.delete_target(name, target, server_suffix)
    local cache_key = "sync_eureka_apps:target:" .. name .. ":" .. target
    LOG_WARN("[delete target]: upstream name :", name .. SERVER_SUFFIX_LIST[server_suffix], " ,target:", target)
    kong_cache:safe_set(cache_key, nil)
    admin_client(HTTP_METHODS.METHOD_DELETE, "/upstreams/" .. name .. SERVER_SUFFIX_LIST[server_suffix] "/targets/" .. target, nil)
end

-- 创建target 为 ups
--- add target to upstream
---@param name string app name
---@param target string app host:port
---@param weight number 0-1000  default 100
---@param tags table tags
function KongAdminOperation.put_target(name, target, weight, tags, server_suffix)
    -- get_targets use(fetch targets)
    local upsName = name .. SERVER_SUFFIX[server_suffix]
    local targets = KongAdminOperation.get_targets(name, "/upstreams/" .. upsName .. "/targets")
    if not targets then
        return nil, "targets is nil"
    end
    weight = weight or 0
    local kong_weight = targets[target] or 0

    if weight ~= kong_weight then
        -- kong not have this target
        if kong_weight ~= 0 then
            delete_target(name, target)
        end
        -- weight == 0 means starting and out_of_service
        -- kong_weight == 0 means this target not in kong upstream
        -- weight == 100 means eureka status is up
        if weight == 0 or (kong_weight == 0 and weight ~= 100) then
            return "ok", nil
        end
    else
        return "ok", nil
    end

    -- 创建target
    LOG_DEBUG("[add target]: name:", name, " ,target:", target)
    local res, err = admin_client(HTTP_METHODS.METHOD_POST, "/upstreams/" .. upsName .. "/targets", {
        target = target,
        weight = weight or 1,
        tags = tags or {}
    })
    local cache_key = "sync_eureka_apps:target:" .. name .. ":" .. target
    parse_resp("target", res, err, cache_key)
end

--- 拉取kong的 ups,为定期摘除做准备
--- fetch kong's upstream
---@param upstream_next string url of next upstream page
function KongAdminOperation.kong_upstreams(upstream_next, server_suffix)
    local server_suffix_key = SERVER_SUFFIX_LIST[server_suffix]
    LOG_DEBUG("[fetch kong's upstream]: path:", upstream_next or "/upstreams")
    local res, err = admin_client(HTTP_METHODS.METHOD_GET, upstream_next or "/upstreams", nil)
    if not res or res.status ~= 200 then
        return nil, "failed to fetch kong's upstreams" .. err
    end
    local ups = cjson.decode(res.body)
    local upstreams = {}
    for _, item in pairs(ups["data"]) do
        if string.sub(item["name"], -string.len(server_suffix_key)) == server_suffix_key then
            upstreams[item["name"]] = string.sub(item["name"], 1, #item["name"] - #server_suffix_key)
        end
    end
    if ngx.null ~= ups["next"] then
        local next_ups = kong_upstreams(ups["next"])
        for key, value in pairs(next_ups) do
            upstreams[key] = value
        end
    end
    LOG_DEBUG("[get kong's upstreams]: next page, path:", ups["next"], " ,this page size:", #ups["data"])
    return upstreams
end

-- select plugin
function KongAdminOperation.getCurrentPlugin(pluginName)
    local sync_server_plugin = nil
    local cache_key = plugins:cache_key(pluginName)
    print("插件的缓存-key：" .. cache_key)
    if cache_key then
        --根据key 查询插件对象
        sync_server_plugin = plugins:select_by_cache_key(cache_key)
    end
    print("\n" .. "=======pluginName 开始...=====cache_key" .. cache_key .. "====" .. cjson.encode(sync_server_plugin) .. "=========")
    return sync_server_plugin
end

return KongAdminOperation